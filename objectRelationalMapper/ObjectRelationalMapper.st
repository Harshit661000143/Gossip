Object subclass: #ORMEntity	instanceVariableNames: 'database_connection columns updateStream updatedColumns'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjectRelationalMapper'!!ORMEntity commentStamp: '<historical>' prior: 0!!!ORMEntity methodsFor: 'as yet unclassified' stamp: 'hd 7/28/2014 03:01'!add: assoc Where:aColumn operator:aoperator value:aValue"To talk to the database we need to print the syntax exactly as desired by the SQL database and we will then pass that printed syntax from SmallTalk to SQL database through a connector""One of the most common line to be used when making an update or selecting something from the database is where columnxyz=ThisParticularValue""We realized that having a method to print this stream which then can be used by all the printSyntax methods will be very very useful, so we have done exactly that this will be used in printsyntax methods where in a select query is made or in the printsyntax method where in a update has to be made""This method only stores that stream in an instance variable called updateStream when a user inputs something and uses this method to input in his wish of update or select but is actually returned to the printsyntax methods via a separate method called updateWhen""If user has entered aColumn as EmployeeID and value as 1, it will create stream as EmployeeID = 1"aValue:= aValue asString.updateStream nextPutAll: assoc; nextPut: $ ;space; nextPutAll: aColumn, aoperator, aValue .! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'jaa 7/25/2014 14:04'!updatecolumns"we have seen that we are smartly using two dictionaries1. To store the name of the column and their datatypes for the table to be created for each entity present as a subclass of the ORMEntity2. To store the name of the column and their corresponding values which need to be inserted/updated in the table of the database for each entity""Now when an update has to be made, we are simply rewriting a new second type of dictionary where in the columnname willbe the name of the column where an update has to be made, now since our dictionary is predefined with all the columns, the rest of the columnname will carry the nil value right.. so we need to remove those nil values to reuse that second type dictionary to actually cause an update so we are doing that in this method in which we are readying a secondtype dictionary so that it does not have an nil value element which would then cause problems when printingoutsyntax for the update query in the ORM Entity superclass"	"Here first we need to remove the keysandvalue for which user doesn't wants update, so first we remove them."	| tempcolumns |	tempcolumns:= Dictionary new.	(columns associationsDo: [ :assoc | assoc value isNil		ifFalse:		[tempcolumns at:(assoc key) put: (columns removeKey: (assoc key))]]).	^(tempcolumns associations collect: [ :assoc |		assoc key asString, '= ', assoc value asString ])		joinUsing: $,.! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 18:23'!getUpdatedValues		| values |	"Transcript show: columns."	columns:= Dictionary new.	values:= self values.	updatedColumns keysAndValuesDo: [ :column :updated | 			(updated=true) ifTrue:			[columns at: column put: (values at: column)]].	"Transcript show: columns."! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 04:23'!printSyntaxToCreateTable"To talk to the database we need to print the syntax exactly as desired by the SQL database and we will then pass that printed syntax from SmallTalk to SQL database through a connector""In this particular method, we are doing exactly that i.e. printing out the exact syntax that a SQL database would want and then we will pass this printed syntax in the form of a query to the connector which will then transmit it to the SQL database which will then finally execute that command""This is a generalized method which is a good thing because this method use another generalized method called columns which returns the list of all the columns desired/needed by reading in the dictionary which will be inherent to all the enity and will be specific for each one of them"" This is a very clean generalized method to use the dictionary that every entity creates and prints it out in a syntax that the SQL database will understand and create/update/insert values in the  given table(this is also generalized and is returned by a method of the entiy) of the database""It creates table, where tableName gives the name of table, and columns method defined on the class side gives the column name and its data type""The implementation is very smooth and clean as you can see that we are first declaring a temporary variable called aStream which will be a string stream and in it we are putting everything that we need to complete the syntax.The nextPutAll: prints out all that is needed/desired into the aStream string stream""we are making use of the super class usefule methods called tablename and columns..both these methods in itself take in a subclass entity as an input and throw out the attributes of that entity subclass. The attributes would include things like the columns needed for that entity( columns method) and the tablename for that particular entity" "Do Refer to the methods called tableName and columns in the class side of the ORM Entity which is the superclass of all the entities . The subclasses send their dictionaries to the columns method in the class side of the ORMEntity which in turns return the list of all the columns required by that particular entity represented by the entity subclass" | aStream |aStream := WriteStream on:String new .aStream nextPutAll: 'CREATE TABLE ', self class tableName, '(', self class columns,')' ."in the step right above, we are using the foreignKeyDictionaryReturn method to return the foreignkeydictionary of the entity and we  are going to each value of it to append it to syntax we are printing out to create table ""if you would see the implementation of this dictionary you would notice that values of the dictionary in the entity itself were writen such tha they can be directly appended to the syntax for creating tables and this is exactly what we are doing here""the entity designated will have a non nil foreignkeydictionary based on what user wanted and that is something which can be dynamically changed and that foreignkey dictionary is being returned in the foreignkeyDictionaryReturn method and that returned dictionary's values are being used to write appropriate syntax for  creating table with the foreigns key as the user wanted"Transcript show: aStream contents;cr;cr.^aStream contents.! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'hd 7/28/2014 02:34'!initialize	super initialize.	updateStream:= WriteStream on:String new.! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 20:50'!printSyntaxToSelectValuesofTable"To talk to the database we need to print the syntax exactly as desired by the SQL database and we will then pass that printed syntax from SmallTalk to SQL database through a connector""In this particular method, we are doing exactly that i.e. printing out the exact syntax that a SQL database would want and then we will pass this printed syntax in the form of a query to the connector which will then transmit it to the SQL database which will then finally execute that command""This is a generalized method which is a good thing because this method use another generalized method called columns which returns the list of all the columns desired/needed by reading in the dictionary which will be inherent to all the enity and will be specific for each one of them"" This is a very clean generalized method to use the dictionary that every entity creates and prints it out in a syntax that the SQL database will understand and create/update/insert values in the  given table(this is also generalized and is returned by a method of the entiy) of the database""It creates table, where tableName gives the name of table, and columns method defined on the class side gives the column name and its data type""The implementation is very smooth and clean as you can see that we are first declaring a temporary variable called aStream which will be a string stream and in it we are putting everything that we need to complete the syntax.The nextPutAll: prints out all that is needed/desired into the aStream string stream""we are making use of the super class usefule methods called tablename and columns..both these methods in itself take in a subclass entity as an input and throw out the attributes of that entity subclass. The attributes would include things like the columns needed for that entity( columns method) and the tablename for that particular entity" "Do Refer to the methods called tableName and columns in the class side of the ORM Entity which is the superclass of all the entities . The subclasses send their dictionaries to the columns method in the class side of the ORMEntity which in turns return the list of all the columns required by that particular entity represented by the entity subclass""updatewhen is an instance side method which returns the position of the row given a certain marker where the update has to take place, this is a very generalized method to return the marker and is used when we have to select some row/rows from the tablename(also returned by the method)""It simply selects * from entire table, we need to add where clause here" | aStream |aStream := WriteStream on: String new. aStream nextPutAll: 'SELECT * FROM ', self class tableName.Transcript show: self When;cr.self When isNil ifFalse:[aStream nextPutAll: ' WHERE ', self When]. Transcript show: aStream contents;cr.^aStream contents.! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'hd 7/28/2014 02:32'!printSyntaxToUpdateValuesofTable"To talk to the database we need to print the syntax exactly as desired by the SQL database and we will then pass that printed syntax from SmallTalk to SQL database through a connector""In this particular method, we are doing exactly that i.e. printing out the exact syntax that a SQL database would want and then we will pass this printed syntax in the form of a query to the connector which will then transmit it to the SQL database which will then finally execute that command""This is a generalized method which is a good thing because this method use another generalized method called columns which returns the list of all the columns desired/needed by reading in the dictionary which will be inherent to all the enity and will be specific for each one of them"" This is a very clean generalized method to use the dictionary that every entity creates and prints it out in a syntax that the SQL database will understand and create/update/insert values in the  given table(this is also generalized and is returned by a method of the entiy) of the database""It creates table, where tableName gives the name of table, and columns method defined on the class side gives the column name and its data type""The implementation is very smooth and clean as you can see that we are first declaring a temporary variable called aStream which will be a string stream and in it we are putting everything that we need to complete the syntax.The nextPutAll: prints out all that is needed/desired into the aStream string stream""we are making use of the super class usefule methods called tablename and columns..both these methods in itself take in a subclass entity as an input and throw out the attributes of that entity subclass. The attributes would include things like the columns needed for that entity( columns method) and the tablename for that particular entity" "Do Refer to the methods called tableName and columns in the class side of the ORM Entity which is the superclass of all the entities . The subclasses send their dictionaries to the columns method in the class side of the ORMEntity which in turns return the list of all the columns required by that particular entity represented by the entity subclass""Here updatecolumns is a method defined on instance side of entity, which is used to return which values has to be updated. updateWhen is used to return the where clause for e.g where ID=1""updatewhen is an instance side method which returns the position of the row given a certain marker where the update has to take place, this is a very generalized method to return the marker and is used when we have to select some row/rows from the tablename(also returned by the method)" | aStream |aStream := WriteStream on: String new. aStream nextPutAll: 'UPDATE ', self class tableName,' SET ', self updatecolumns, ' WHERE  ', self When. Transcript show: aStream contents;cr;cr.^aStream contents.! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 20:51'!When"To talk to the database we need to print the syntax exactly as desired by the SQL database and we will then pass that printed syntax from SmallTalk to SQL database through a connector""One of the most common line to be used when making an update or selecting something from the database is where columnxyz=ThisParticularValue""We realized that having a method to print this stream which then can be used by all the printSyntax methods will be very very useful, so we have done exactly that this will be used in printsyntax methods where in a select query is made or in the printsyntax method where in a update has to be made""If user has entered aColumn as EmployeeID and value as 1, it will create stream as EmployeeID = 1 in the updateWhere:value: method, in this method it will actually get returned and used by print syntax methods"	"update stream is being created during updateWhere:value: method"			updateStream isNil 		ifFalse: [^updateStream contents]		ifTrue:  [^nil]	! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'jaa 7/25/2014 00:06'!printSyntaxToInsertValuesintoTable | aStream |"To talk to the database we need to print the syntax exactly as desired by the SQL database and we will then pass that printed syntax from SmallTalk to SQL database through a connector""In this particular method, we are doing exactly that i.e. printing out the exact syntax that a SQL database would want and then we will pass this printed syntax in the form of a query to the connector which will then transmit it to the SQL database which will then finally execute that command""This is a generalized method which is a good thing because this method use another generalized method called columns which returns the list of all the columns desired/needed by reading in the dictionary which will be inherent to all the enity and will be specific for each one of them"" This is a very clean generalized method to use the dictionary that every entity creates and prints it out in a syntax that the SQL database will understand and create/update/insert values in the  given table(this is also generalized and is returned by a method of the entiy) of the database""It creates table, where tableName gives the name of table, and columns method defined on the class side gives the column name and its data type""The implementation is very smooth and clean as you can see that we are first declaring a temporary variable called aStream which will be a string stream and in it we are putting everything that we need to complete the syntax.The nextPutAll: prints out all that is needed/desired into the aStream string stream""we are making use of the super class usefule methods called tablename and columns..both these methods in itself take in a subclass entity as an input and throw out the attributes of that entity subclass. The attributes would include things like the columns needed for that entity( columns method) and the tablename for that particular entity" "Do Refer to the methods called tableName and columns in the class side of the ORM Entity which is the superclass of all the entities . The subclasses send their dictionaries to the columns method in the class side of the ORMEntity which in turns return the list of all the columns required by that particular entity represented by the entity subclass""This columns method is defined on instance side of entity, which gives the values for that row."aStream := WriteStream on: String new. aStream nextPutAll: 'INSERT INTO ', self class tableName,' VALUES(', self columns,')'.Transcript show: aStream contents;cr;cr.     ^aStream contents.! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 04:35'!columns"So ORMEntity is the superclass of all the entities where each entity should have a table with the respective columns in them""To talk to the database, we need to printout  the syntax desired by the database to execute the queries""Would it have been feasible if we were creating a hardcoded print syntax methods for each of the entities...ofcourse not..we would run into terrible problems if a user decides to change the columns i.e. delete or add new ones because then we would have to go in and change in the syntax in the printsyntax methods of that entity""similarly the problem would have been there if we were to actually insert values into a row of the table, we would have to create methods for each of the entity to print syntax relevant to them..ofcourse that would have been bad coding"" to solve the problem of managing the column name and their datatype for each entity , we created a dictionary storing both of the two for each entity which will then pass it to a superclass which will then do the job for the entity subclass""to solve the problme of inserting the values, we need to fetch the values from that entity subclass, the best way to fetch it and store it such that it can be used in a generalized form by the entity superclass, we created another dictionary, this dictionary will store the actual value against the key, where the key will simple be the column name so difference between the two dictionaries is that one of the stores the datatype against the column name and the other one stores the value against the column name"" This method iterates over the second type dictionary(stored in an instance side variable called columns, this is sent by the entity subclass to it ) and returns the value in a nice string stream which can be directly used by the pritnsyntax methods (of the ORM entity superclass)to insert or update values of the tablename in the database""Every row has their own dictionary named column which is used to store the values in a row In this method we return those values during insert query"	^(columns values collect: [ :value |  value asString ])    joinUsing: $,.! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'hd 7/28/2014 02:39'!Where:aColumn operator:aoperator value:aValue"To talk to the database we need to print the syntax exactly as desired by the SQL database and we will then pass that printed syntax from SmallTalk to SQL database through a connector""One of the most common line to be used when making an update or selecting something from the database is where columnxyz=ThisParticularValue""We realized that having a method to print this stream which then can be used by all the printSyntax methods will be very very useful, so we have done exactly that this will be used in printsyntax methods where in a select query is made or in the printsyntax method where in a update has to be made""This method only stores that stream in an instance variable called updateStream when a user inputs something and uses this method to input in his wish of update or select but is actually returned to the printsyntax methods via a separate method called updateWhen""If user has entered aColumn as EmployeeID and value as 1, it will create stream as EmployeeID = 1"aValue:= aValue asString.updateStream nextPutAll: aColumn, aoperator, aValue .! !!ORMEntity methodsFor: 'as yet unclassified' stamp: 'jack 7/30/2014 17:30'!getObjectValues:aObject"So ORMEntity is the superclass of all the entities where each entity should have a table with the respective columns in them""To talk to the database, we need to printout  the syntax desired by the database to execute the queries""Would it have been feasible if we were creating a hardcoded print syntax methods for each of the entities...ofcourse not..we would run into terrible problems if a user decides to change the columns i.e. delete or add new ones because then we would have to go in and change in the syntax in the printsyntax methods of that entity""similarly the problem would have been there if we were to actually insert values into a row of the table, we would have to create methods for each of the entity to print syntax relevant to them..ofcourse that would have been bad coding"" to solve the problem of managing the column name and their datatype for each entity , we created a dictionary storing both of the two for each entity which will then pass it to a superclass which will then do the job for the entity subclass""to solve the problme of inserting the values, we need to fetch the values from that entity subclass, the best way to fetch it and store it such that it can be used in a generalized form by the entity superclass, we created another dictionary, this dictionary will store the actual value against the key, where the key will simple be the column name so difference between the two dictionaries is that one of the stores the datatype against the column name and the other one stores the value against the column name"" This method stores this second type dictionary(stored in an instance side variable called columns, this is sent by the entity subclass to it ) and this dictionaries value is returned in a nice string stream format by an instance method called columns of the ORM entity superclasss which can be directly used by the pritnsyntax methods (of the ORM entity superclass)to insert or update values of the tablename in the database""Every row has their own dictionary named column which is used to store the values in a row In this method we return those values during insert query"	"It simply takes the dictionary in columns, like values in each column for that particular row"	columns:= aObject values.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ORMEntity class	instanceVariableNames: 'columns tableName primarykey aStream'!!ORMEntity class commentStamp: '<historical>' prior: 0!!!ORMEntity class methodsFor: 'as yet unclassified' stamp: 'hd 7/27/2014 22:38'!primarykey	^primarykey! !!ORMEntity class methodsFor: 'as yet unclassified' stamp: 'DigvijaySingh 7/23/2014 12:37'!columns: aDictionary"So ORMEntity is the superclass of all the entities where each entity should have a table with the respective columns in them""To talk to the database, we need to printout  the syntax desired by the database to execute the queries""Would it have been feasible if we were creating a hardcoded print syntax methods for each of the entities...ofcourse not..we would run into terrible problems if a user decides to change the columns i.e. delete or add new ones because then we would have to go in and change in the syntax in the printsyntax methods of that entity""Best way to deal with the above problem is to create a dictionary where key will be the name of the column and the value will be the datatype""so we can add columns to that dictionary if we want to add an extra column or delete column from that dictionary if we want to delete it"" That particular dictionary inherent to each of the entity under the entity superclass will be used to print relevant syntax for that particular entity so that operations pertaining to that particular entity can be performed on the database""This method is on the class side of the ORM Entity which is the superclass of all the entity classes, this will take in a dictionary returned by any of it's entity subclasses and will store it or override it in a class variable called columns""That particular columns variable which is now a dictionary of any of the entity, will now be used to print syntaxes for that particular entity in the printsyntax methods of the ORM entity...so this way we need not write in separate printSyntax methods for each of the entity since these methods in the superclass can do that job for ALL the entities as long as entities provide them with their correct dictionary containing the names of the columns and their datatypes"	"A [ not a ] dictionary containing the mapping of all the columns with their respective datatypes"		columns:= aDictionary! !!ORMEntity class methodsFor: 'as yet unclassified' stamp: 'hd 7/27/2014 22:35'!setprimarykey:aPrimarykey primarykey:= aPrimarykey! !!ORMEntity class methodsFor: 'as yet unclassified' stamp: 'DigvijaySingh 7/23/2014 12:48'!tableName "So ORMEntity is the superclass of all the entities where each entity should have a table with the respective columns in them""To talk to the database, we need to printout  the syntax desired by the database to execute the queries""Would it have been feasible if we were creating a hardcoded print syntax methods for each of the entities...ofcourse not..we would run into terrible problems if a user decides to change the columns i.e. delete or add new ones because then we would have to go in and change in the syntax in the printsyntax methods of that entity""The most important component of any database query will be the tablename in which we want to execute the query and each entity will have a particular table that it is mapped to""since entities are themselves not printing out syntax to communicate to database instead a superclass is doing it for ALL the entities(subclasses), we need a way so that the entities can send in their information to the superclass which in turns will print the syntax and run the query for them""So here we are simple taking in the tablename as an argument (this will be supplied by any of the entity subclass), it will get stored /overridden in a class side variable called tableName and will be used by the printSyntax methods of the superclass ORMEntity to print relevant syntax for the entity which sent it's table name in the first place""similar to needing the basic information of the table name, we also need other stuff such as column name, values in them and their datatype and we do have methods to handle those separately as well"" in a method called tableName:, we actually took the name of the tableName from any of the entity subclass and stored it in a class variable called tableName , we are here simply  returning it/printing it. This particular return/print will then be used by all the print syntax methods in the superclass ORM entity to print out relevant syntax for the particular entity subclass which sent it's tableName in the first place"	^ tableName! !!ORMEntity class methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 04:20'!setForeignKey: foreignKeyColumnName pointingTo: tablename primaryKey: primaryKeyNameaStream := WriteStream on:String new .aStream nextPutAll: 'FOREIGN KEY ',' ','(',foreignKeyColumnName,')',' ' ,'REFERENCES',' ', tablename,'(',primaryKeyName,')'! !!ORMEntity class methodsFor: 'as yet unclassified' stamp: 'DigvijaySingh 7/23/2014 12:48'!tableName: table "So ORMEntity is the superclass of all the entities where each entity should have a table with the respective columns in them""To talk to the database, we need to printout  the syntax desired by the database to execute the queries""Would it have been feasible if we were creating a hardcoded print syntax methods for each of the entities...ofcourse not..we would run into terrible problems if a user decides to change the columns i.e. delete or add new ones because then we would have to go in and change in the syntax in the printsyntax methods of that entity""The most important component of any database query will be the tablename in which we want to execute the query and each entity will have a particular table that it is mapped to""since entities are themselves not printing out syntax to communicate to database instead a superclass is doing it for ALL the entities(subclasses), we need a way so that the entities can send in their information to the superclass which in turns will print the syntax and run the query for them""So here we are simple taking in the tablename as an argument (this will be supplied by any of the entity subclass), it will get stored /overridden in a class side variable called tableName and will be used by the printSyntax methods of the superclass ORMEntity to print relevant syntax for the entity which sent it's table name in the first place""similar to needing the basic information of the table name, we also need other stuff such as column name, values in them and their datatype and we do have methods to handle those separately as well"	tableName:= table	! !!ORMEntity class methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 04:17'!columns|string size count|"This method returns the column name and its data type that is required for create query in database. Now if the table has a primary key that will be stored in variable primarykey. Now we iterate over a dictionary with each key and value and print them on a string. If key of dictionary is same as primarykey set for the table, we add PRIMARY KEY to string." string:= WriteStream on: String new."Transcript show: primarykey;cr."size:= columns size.count:= 1.columns keysAndValuesDo: [ :key :value| key==primarykey 		ifTrue:[string nextPutAll: key asString; nextPut:$ ;space;nextPutAll:value asString; nextPut:$ ;space;nextPutAll:'PRIMARY KEY'.count<size ifTrue:[count := count + 1. string nextPut:$, ]]		ifFalse:[		string nextPutAll: key asString; nextPut:$ ;space;nextPutAll: value asString. count<size ifTrue: [count := count +1. string nextPut:$,]]]. aStream isNil ifFalse: [ string nextPut:$,;space; nextPutAll:aStream contents  ].	^string contents.  ! !Object subclass: #ORMSession	instanceVariableNames: 'database_connection'	classVariableNames: ''	poolDictionaries: ''	category: 'ObjectRelationalMapper'!!ORMSession commentStamp: '<historical>' prior: 0!!!ORMSession methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 03:55'!createObjectAttributes: argument1    | queryStream |    queryStream := argument1 printSyntaxToCreateTable.   database_connection executeQuery: queryStream.! !!ORMSession methodsFor: 'as yet unclassified' stamp: 'hd 7/22/2014 23:50'!getObjectValues:aObject      "Here aObject is a instance of Employee class, which transfers the message to ORMEntity. There it simply takes the dictionary of that row in its variable named column "	aObject getObjectValues:aObject! !!ORMSession methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 18:32'!save: aEntity"Here I have removed queryStream:= OrderedCollection new, because if we use that we need to execute the queryStream with index. For e.g database_connection executeQuery: queryStream at:index, We may need this during atomicity but for the time being that could be removed"    | queryStream primaryKey |	primaryKey:= Dictionary new.	primaryKey:= aEntity class primarykey.	aEntity getUpdatedValues.	aEntity Where:primaryKey operator:'=' value:(aEntity values at:primaryKey).    queryStream:= aEntity printSyntaxToUpdateValuesofTable.    database_connection executeQuery: queryStream."argument1 is simply the entity that will be passsed for which we need to update the entity's attributes as a existing row in one table at the database""This is an update method so we assumen that the table has already been created""All it does is it uses entity's own method of  printing the syntax(printSyntaxToUpdateValuesofTable) for updating values relevant to that entity and does an executequery for actually executing the query"! !!ORMSession methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 05:05'!createDatabase: argument1|queryStream|	"just creates the database with the name of the argument1 passed and creates an instance of this database creation for later to execute queries on to this instance variable called database_connection in this case"	database_connection := SQLiteConnection fileNamed: argument1.	queryStream:= 'PRAGMA foreign_keys = ON'.	database_connection executeQuery: queryStream.! !!ORMSession methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 05:38'!insertObjectAttributes: argument1    | queryStream |      (argument1 decidetable) < 2         ifTrue:[database_connection executeQuery: argument1 printSyntaxToCreateTable].    queryStream := argument1 printSyntaxToInsertValuesintoTable.    database_connection executeQuery: queryStream."Argument1 is simply the entity that will be passsed for which we need to insert the entity's attributes as a new row in one table at the database""First we check if the table has not been created then we check the constructor value of the entity passed if the constructor value is zero it  means the entity has never been used meaning there is possibly no table for that entity so we create a table for it""For crearing table, we use entity's own method of printing the syntax to create table and use that syntax by adding it into a stream and then passing that stream into execute query method simply""If there is already a table or now that a new table is created ...all  it does is it uses entity's own method of printing the syntax(printSyntaxToInsertValuesintoTable) for inserting values relevant to that entity and does an executequery for actually executing the query"	! !!ORMSession methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 20:28'!selectObjectAttributes: argument1    | queryStream result newResult |result:= WriteStream on: String new.    queryStream:= argument1 printSyntaxToSelectValuesofTable.	result:= (database_connection executeQuery: queryStream).	result size = 1 		ifTrue: [ newResult:= Employee new columns: (result at:1)]		ifFalse: [ newResult:= Bag new.			result do: [ :each | newResult add:(Employee new columns:each)]].	^newResult."argument1 is simply the entity that will be passsed for which we need to update the entity's attributes as a existing row in one table at the database""This is an update method so we assumen that the table has already been created""All it does is it uses entity's own method of  printing the syntax(printSyntaxToUpdateValuesofTable) for updating values relevant to that entity and does an executequery for actually executing the query"! !!ORMSession methodsFor: 'as yet unclassified' stamp: 'hd 7/22/2014 23:53'!updateObjectAttributes: argument1"Here I have removed queryStream:= OrderedCollection new, because if we use that we need to execute the queryStream with index. For e.g database_connection executeQuery: queryStream at:index, We may need this during atomicity but for the time being that could be removed"    | queryStream |    queryStream:= argument1 printSyntaxToUpdateValuesofTable.    database_connection executeQuery: queryStream."argument1 is simply the entity that will be passsed for which we need to update the entity's attributes as a existing row in one table at the database""This is an update method so we assumen that the table has already been created""All it does is it uses entity's own method of  printing the syntax(printSyntaxToUpdateValuesofTable) for updating values relevant to that entity and does an executequery for actually executing the query"! !