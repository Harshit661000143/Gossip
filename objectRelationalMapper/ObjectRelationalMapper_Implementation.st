ORMEntity subclass: #Employee	instanceVariableNames: 'columnvalues'	classVariableNames: 'Decidetable25'	poolDictionaries: ''	category: 'ObjectRelationalMapper_Implementation'!!Employee commentStamp: '<historical>' prior: 0!!!Employee methodsFor: 'as yet unclassified' stamp: 'jack 7/30/2014 17:18'!last_name: argument1	columnvalues at:#LastName put: argument1.	updatedColumns at:#LastName put:true.	"Takes in the arguments for the last name of the employee and stores it in an instance variable"! !!Employee methodsFor: 'as yet unclassified' stamp: 'jaa 7/25/2014 12:12'!columns: aRow		columnvalues := aRow.! !!Employee methodsFor: 'as yet unclassified' stamp: 'DigvijaySingh 7/24/2014 09:15'!values"It is used to return the dicrionary, used by ORMEntity class, during getObjectvalues"	^columnvalues"So ORMEntity is the superclass of all the entities where each entity should have a table with the respective columns in them""To talk to the database, we need to printout  the syntax desired by the database to execute the queries""Would it have been feasible if we were creating a hardcoded print syntax methods for each of the entities...ofcourse not..we would run into terrible problems if a user decides to change the columns i.e. delete or add new ones because then we would have to go in and change in the syntax in the printsyntax methods of that entity""similarly the problem would have been there if we were to actually insert values into a row of the table, we would have to create methods for each of the entity to print syntax relevant to them..ofcourse that would have been bad coding"" to solve the problem of managing the column name and their datatype for each entity , we created a dictionary storing both of the two for each entity which will then pass it to a superclass which will then do the job for the entity subclass""to solve the problme of inserting the values, we need to fetch the values from that entity subclass, the best way to fetch it and store it such that it can be used in a generalized form by the entity superclass, we created another dictionary, this dictionary will store the actual value against the key, where the key will simple be the column name so difference between the two dictionaries is that one of the stores the datatype against the column name and the other one stores the value against the column name"" This method returns the values of the second type dictionary and this returned value is then used to print syntaxes for the actual query that will be sent to SQL database""Every row has their own dictionary named column which is used to store the values in a row In this method we return those values during insert query"! !!Employee methodsFor: 'as yet unclassified' stamp: 'jack 7/30/2014 17:17'!employee_ID: argument1	(argument1 isNumber)      ifTrue:[columnvalues at:#EmployeeID put: argument1.			updatedColumns at:#EmployeeID put:true]      ifFalse:['The Employee ID has to be an Integer'].    "Takes in the correct argument for the employeeID and stores it in an instance variable...if the argumentCount  is not in the right format that is integer, then it will display an error"! !!Employee methodsFor: 'as yet unclassified' stamp: 'jack 7/30/2014 17:18'!salariedAt: argument1     (argument1 isNumber)      ifTrue:[columnvalues at:#Salary put:argument1.			updatedColumns at:#Salary put:true.]      ifFalse:['Salary has to be an Integer'].! !!Employee methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 04:18'!initialize	super initialize.	"self decidetable isNil"	"doesn't work with me coz 'self decidetable is 'nil'' and it doesNotUnderstand isNil :| :| :| "	"Okay so now the self class initialize will take place only once because decidetablevariable is a class side variable which is going to be consistent throughout the class and all the instances of the class and hence only when decidetable=1 that we need to initialize the class side initialize which will establish the mapping and create appropriate tables and columns"	 "We were initially doing a dirty(by not putting this if condition) but non harmful and seemingly safe thing here,with each initialization of the instance created, I am also forcing the initialize method of the class side to run which will do nothing but keep incrementing the decidetable variable's value but it is harmful since the decision to create tables and columns only happens once when decidedtable is nil....the reason I am putting it here for safety is because suppose the user failed to do ""Employee class initialize"" in the workspace, then we would be in trouble as the tables and columns mapping would not have reached the ORMSession to create tables and columns for all the future instances of the Employee class so we  are doing this here just for that safety precaution""This dictionary is on the instance side of Employee, which is used to take values for that particular row"	self class initialize.		updatedColumns:= self createdictionary.			columnvalues:= self createdictionary		"So ORMEntity is the superclass of all the entities where each entity should have a table with the respective columns in them""To talk to the database, we need to printout  the syntax desired by the database to execute the queries""Would it have been feasible if we were creating a hardcoded print syntax methods for each of the entities...ofcourse not..we would run into terrible problems if a user decides to change the columns i.e. delete or add new ones because then we would have to go in and change in the syntax in the printsyntax methods of that entity""similarly the problem would have been there if we were to actually insert values into a row of the table, we would have to create methods for each of the entity to print syntax relevant to them..ofcourse that would have been bad coding"" to solve the problem of managing the column name and their datatype for each entity , we created a dictionary storing both of the two for each entity which will then pass it to a superclass which will then do the job for the entity subclass""to solve the problme of inserting the values, we need to fetch the values from that entity subclass, the best way to fetch it and store it such that it can be used in a generalized form by the entity superclass, we created another dictionary, this dictionary will store the actual value against the key, where the key will simple be the column name so difference between the two dictionaries is that one of the stores the datatype against the column name and the other one stores the value against the column name""Here in this method, we are actually putting nil values to do those dictionary and the instance will gather values as it goes ahead""Every row has their own dictionary named column which is used to store the values in a row In this method we return those values during insert query"! !!Employee methodsFor: 'as yet unclassified' stamp: 'jack 7/30/2014 17:18'!middle_name: argument1	columnvalues at:#MiddleName put: argument1.	updatedColumns at:#MiddleName put:true.	"Takes in the arguments for the middle name of the employee and stores it in an instance variable"! !!Employee methodsFor: 'as yet unclassified' stamp: 'DigvijaySingh 7/22/2014 01:28'!insert: argument1argument1 insertObjectAttributes: self "argument1will be an instance of the ORMSession which is what we are using to communicate to the database, it is an altogether new class and in the class there is a method called insertObjectAttributes which takes in Entity as an argument and the insert the entities attributes as a new row in the table of the database""Details will be much clearer if one were to read the  insertObjectAttributes ..what it does is it uses entity's own method of printing the syntax(printSyntaxToInsertValuesintoTable) for inserting values relevant to that entity and does an executequery for actually executing the query"! !!Employee methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 21:07'!createdictionary	| dict |	dict := Dictionary new.	dict at: #EmployeeID put: nil .	dict at: #LastName put: nil.	dict at: #MiddleName put:nil.	dict at: #FirstName put: nil.	dict at: #DateofBirth put: nil.	dict at: #Salary put: nil.	^dict! !!Employee methodsFor: 'as yet unclassified' stamp: 'jack 7/30/2014 17:17'!date_Of_Birth: argument1"I had to comment this check because I couldn't figure out how to use it during stream. "    "  (argument1 isMemberOf: Date)       ifTrue: [dateofbirth:=argument1]       ifFalse:[^'The Date of Birth has to be in the Date Format of SmallTalk']"	columnvalues at:#DateofBirth put:argument1.	updatedColumns at:#DateofBirth put:true"Takes in the correct argument for the date of birth of the employee and stores it in an instance variable...if the date is not in the right format, then it will display an error"	! !!Employee methodsFor: 'as yet unclassified' stamp: 'jack 7/30/2014 17:18'!first_name: argument1	columnvalues at:#FirstName put:argument1.	updatedColumns at:#FirstName put:true.	"Takes in the arguments for the first name of the employee and stores it in an instance variable"! !!Employee methodsFor: 'as yet unclassified' stamp: 'DigvijaySingh 7/30/2014 09:21'!getInstanceWherePrimaryID: primaryKeyArgument | aStream  newInstanceofThisEntity list streamLines line1_separated line2_separated count|."This is the method which will return you a brand new instance of your entity with all the attributes in that instance similar to the one present in the row of the table which has the given particular |primaryKeyArgument| as it's primary key"self Where: self primarykey operator:'=' value:primaryKeyArgument."Here we are using the inbuilt methods already present in the ORM Entity class to basically create the stream text that we need which we were using to select the values….in the Where section you are basically inputting the NAME of the primary key of that entity and not the primary key itself and the operator is simply equal to and value is the one you passed as an argument of this method""Temporary Variables"aStream := WriteStream on: String new. aStream nextPutAll: 'SELECT * FROM ', self class tableName.self When isNil ifFalse:[aStream nextPutAll: ' WHERE ', self When]. "Since we already ran the method this:self Where: self primarykey operator:'=' value:primaryKeyArgument ...the self When will give us the right kind of stream for executing the query because it basically takes everything from the method we ran just now""The above code will print the right syntax to do a select based on the primary key...plain and simple""Now we will need to parse this aStream and create a new instance and return that instance where that instane will carry all the attributes returned as a row in aStream here"newInstanceofThisEntity  = self new."Just creating a new instance of this entity class and then we will add in attributes to it based on the value returned to you by the select command based on primary key""We are selecting based on the Primary key so there will be only one row and thus only one instance .The query of the select command by the primary key will essentially give out two lines.The first line will be the name of the column names and the second line will contain the values stored in this column names I will go over the first line to fetch column names and second line to fetch their values list is sort of array here and will store two lines in two indexesbelow is the readstream going by the lines and we are storing each line in one index of the list and we will later use this"  list := String new: 2.   "creating a string object to store our two lines"streamLines := aStream readStream. [[streamLines atEnd] 	whileFalse: [| next| 	next := streamLines upTo: Character cr. list add: next]] 		ensure: [streamLines close].		"in the above loop we have added two lines returned from our query into each line of the string object called list"line1_separated := (list at:1) asString findTokens: ''.  line2_separated := (list at:2) asString findTokens: ''.count := 1.newInstanceofThisEntity createdictionary. "Using the createdictionary method of the entity  itself to make a column value dictionary"columnvalues keysAndValuesDo: [:key :value| columnvalues at: key put: line2_separated at: count. 	                        count=count+1.]."columnvalues is the instance side dictionary which stores the value of the various fields and here we are just putting values into that dictionary by the values that we got in the second line of the query output"^newInstanceofThisEntity "returning this instance after putting values in it and now you can update it or do whatever you want with this instance"! !!Employee methodsFor: 'as yet unclassified' stamp: 'DigvijaySingh 7/22/2014 01:30'!updateTable: argument1argument1 updateObjectAttributes: self "argument1will be an instance of the ORMSession which is what we are using to communicate to the database, it is an altogether new class and in the class there is a method called updateObjectAttributes which takes in Entity as an argument and the updates the entities attributes in a row matching with entitities characteirtic marker for e.g. EmployeeID in the case of an Employee...Employee can change his name etc etc. but not his id so Employee ID is a permanent marker of a row in the table""Details will be much clearer if one were to read the  updateObjectAttributes ..what it does is it uses entity's own method of printing the syntax(printSyntaxToUpdateValuesofTable) for updating values relevant to that entity and does an executequery for actually executing the query"! !!Employee methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 18:37'!decidetable"This is very much required, It is a class variable so every instance of Employee shares it. We need it because we want to create the table only at the first instance of Employee. Look at the instance side initialize of Employee, that will help to understand the use of this variable and method better " ^Decidetable25! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Employee class	instanceVariableNames: 'dict'!!Employee class commentStamp: '<historical>' prior: 0!!!Employee class methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 18:37'!initialize	|col|	super initialize.		col:= self createdictionary.	Decidetable25  isNil  "Decidetable12 is a class side variable and thus shared by  *ALL THE INSTANCES* of this class.  This is like a constructor value which gets incremented everytime the class is initialized, the purpose is simple that at the very first initialization of the class, a set of mapping rules should be defined for this class and this mapping rule will be sent to ORMEntity which in turn will send it to ORMSession to actually create tables and columns FOR ALL THE INSTANCES of this class""This mapping will remain consistent for all the instances of the class and hence this is on the class side including the initlization method"		ifTrue:[			super columns: col.			super tableName: 'TestMilestone4'.			Decidetable25 :=  1.		]	ifFalse:[ Decidetable25 := Decidetable25 +1]."JUST BE SURE TO RUN THIS INITIALIZE METHOD AS employee class initialize or employee initialize , this is something which we have to do for the class side initialize method""Okay so we have put this initialize method in the class side of the Employee class...whybecause of following""If put in instance side, the initialize method will work for the *SPECIFIC INSTANCE* and not for *ALL THE INSTANCES* of the employee class...for e.g. if you do t := Employee new. It will do an initialization for t and create tables and columns for the t and if you do this followed by above i.e. s := Employee new. It will do an initialization again (as outlined in the instance method of the Employee class) and it will update the decidetable values which is used to create tables and all). This is an uneffective initializayion because our core interest in initialization method is to initiate the creation of tables and columns for the entire class and all it's intances( which are nothing but rows in the table created) so why do we need to increment decidetable variable at every instance when we need it's value only once at the beginning to take a decision of creating tables and columns""so the part of the initialization which concerned the creation of tables and columns has now been put under class side initialie method and should ideally be run once and be okay for all the future instances of the class""but there was another part to this initialize method which was to put nil values against all the key(columnnames) and then user will use different methods to add values to that particular instance and finally post those values to the database through the appropriate methods so we have kept that part of initialization in the instance side of the class because every instance will begin with the nil values against all column and will propogate further to get values against different column names"! !!Employee class methodsFor: 'as yet unclassified' stamp: 'jaa 7/24/2014 23:30'!createdictionary	dict := Dictionary new.	dict at: #EmployeeID put: Integer .	dict at: #LastName put: Text.	dict at: #MiddleName put:Text.	dict at: #FirstName put: Text.	dict at: #DateofBirth put: Text.	dict at: #Salary put: Float.	"Transcript show:dict;cr."	^dict	"This class side methods specifies the mapping needed to create columns in the table of the database and this method is used in the initialize method in the class side which sends all these mapping info to the ORM Entity which in turn sends to ORM session to create table based on this mapping for *ALL THE INSTANCES* of the Employee class and hence *THIS IS ON THE CLASS SIDE* i.e. applicable to  *ALL THE INSTANCE* of the employee"		"Please refer to the initialize method present in the class side to understand the usefulness of this method"		"(EmployeeID int, LastName varchar(255),MiddleName varchar(255),FirstName varchar(255),DateOfBirth date,Salary float, EmploymentStartDate date,EmploymentEndDate date)' ."! !ORMEntity subclass: #Team	instanceVariableNames: 'columnvalues'	classVariableNames: 'Decidetable22'	poolDictionaries: ''	category: 'ObjectRelationalMapper_Implementation'!!Team commentStamp: '<historical>' prior: 0!!!Team methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 20:40'!teamname: aName      columnvalues at:#TeamName put: aName.	updatedColumns at:#TeamName put:true.! !!Team methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 20:30'!columns: aRow		columnvalues := aRow.! !!Team methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 19:05'!values	^columnvalues ! !!Team methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 04:18'!initialize	super initialize.	self class initialize.			columnvalues:= Dictionary new.	updatedColumns:= self createdictionary.				columnvalues:= self createdictionary	! !!Team methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 21:09'!createdictionary	| dict |	dict := Dictionary new.	dict at: #TeamID put: nil.	dict at: #ManagerID put: nil.	dict at: #TeamName put: nil.	^dict! !!Team methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 20:39'!teamID: anID	(anID isNumber)      ifTrue:[columnvalues at:#TeamID put: anID.			updatedColumns at:#TeamID put:true]      ifFalse:['The Team ID has to be an Integer'].! !!Team methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 19:02'!managerID: anID	(anID isNumber)      ifTrue:[columnvalues at:#ManagerID put: anID.			updatedColumns at:#ManagerID put:true]      ifFalse:['The Manager ID has to be an Integer'].! !!Team methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 19:04'!updateTable: argument1	argument1 updateObjectAttributes: self ! !!Team methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 18:35'!decidetable	^Decidetable22! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Team class	instanceVariableNames: ''!!Team class commentStamp: '<historical>' prior: 0!!!Team class methodsFor: 'as yet unclassified' stamp: 'hd 8/1/2014 18:36'!initialize	super initialize.		Decidetable22  isNil		ifTrue:[			super columns: self createdictionary.			super tableName: 'Milestone4'.			Decidetable22 := 1.		]         ifFalse:[ Decidetable22 := Decidetable22 +1].! !!Team class methodsFor: 'as yet unclassified' stamp: 'jack 7/31/2014 21:04'!createdictionary"This dictionary is very useful, as it takes value at its key, and is used during insert by session."	|dict|	dict := Dictionary new.	dict at: #TeamID put: Integer.	dict at: #ManagerID put: Integer.	dict at: #TeamName put: Text.	^dict! !Employee initialize!Team initialize!